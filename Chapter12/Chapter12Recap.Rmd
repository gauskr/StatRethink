---
title: "Chapter 12: Recap"
author: "Guido Biele"
date: "01.06.2022"
output:
  html_document: 
    mathjax: default
    toc: true
    toc_depth: 2
    code_folding: hide
header-includes: 
    \usepackage{xcolor}
    \usepackage{amsmath}
---

  
```{css, echo = F}
body{
  font-family: Helvetica;
  font-size: 16pt;
  max-width: 1000px;
  margin: auto;
  margin-left:310px;
}
pre{
  font-size: 20px;
}
/* Headers */
h1{
    font-size: 24pt;
  }
h1,h2{
    font-size: 20pt;
  }
h3,h4,h5,h6{
  font-size: 18pt;
}

#TOC {
  position: fixed;
  left: 0;
  top: 0;
  width: 300px;
  height: 100%;
  overflow:auto;
}


```

```{r setup, include=FALSE, message=FALSE, warning=FALSE, results='hide'}
knitr::opts_chunk$set(echo = TRUE, dpi = 300, global.par = TRUE,
                      fig.align = 'center', out.width="80%")
library(rethinking)
library(magrittr)
library(knitr)
library(kableExtra)
library(MASS)
source("../utils.R")

set_par = function(mfrow = c(1,1), mar=c(3,3,.5,.5), cex = 1.25) 
  par(mfrow = mfrow, mar=mar, mgp=c(1.75,.5,0), tck=-.01, cex = cex)

```


# A different view of the logistic regression

We can think of a logistic regression as model in which individuals have a latent trait that determines if they fall in one category or another. For instance, latent scholastic aptitude is a trait that  (co-) determines if a student passes a class:

```{r class.source = 'fold-show'}
threshold = -2
```


```{r out.width="60%"}
set_par(cex = 1.5)
curve(dlogis(x),-6,6, xlim = c(-5,5),
      xlab = "latent scholastic aptitude")
x = seq(threshold,5,.1)
shade(dlogis(x)~x,c(threshold,6), col = adjustcolor("green3",.5))
x = seq(-6,threshold,.1)
shade(dlogis(x)~x,c(-6,threshold), col = adjustcolor("red3",.5))
abline(v = threshold, lty = 2, lwd = 2)
```

In this model, **the latent variable is distributed according to the logistic distribution**.

We can calculate the log odds of an an outcome as before, this time using probabilities.

$$
\textrm{log odds} = log \left( \frac{P_{fail}}{P_{pass}} \right) = log \left( \frac{P_{fail}}{1-P_{fail}} \right)
$$
To get the probability to fail at a certain threshold, we use the cumulative probability function of the logistic distribution, also called the inverse logit:

```{r out.width="60%"}
set_par(cex = 1.5)
curve(plogis(x),-6,6,xlim = c(-5,5),
      xlab = "latent scholastic aptitude",
      ylab = "plogis(x) = inv_logit(x)")
curve(plogis(x),-6,-2,col = "red", add = T, lwd = 1.5)
curve(plogis(x),-2,6,col = "green3", add = T, lwd = 1.5)
lines(c(-6,threshold),rep(plogis(threshold),2), lty = 2, col = "red")
lines(rep(threshold,2),c(0,plogis(threshold)), lty = 2, col = "red")
```



```{r class.source = 'fold-show'}
P_fail = plogis(threshold)
P_pass = 1-P_fail
log_odds = log(P_fail/P_pass)
log_odds
```
This is exactly our threshold.

Now let us assume that there is another variable that increases the probability to pass a class, so that also students with lower latent scholastic aptitude of -3 can pass a class (could be class difficulty).

In a logistic regression we estimate the following:

$$
log \left( \frac{P_{fail}}{P_{pass}} \right) = \alpha + \beta \cdot X
$$
Here $\small \alpha$ is the intercept and baseline log-odds ratio to pass the test (due to latent scholastic aptitude), $\small X$ is our additional variable and $\small \beta$ captures log odds ratio from passing the class due to variable $\small X$.

Because our baseline threshold / log odds ratio is -2 and the threshold for children with variable X is -3, we calculate

$$
\beta = -2 -(-3) = 1
$$

So if we simulate data according to this data generating process and estimate a logistic regression, we should find that $\small \alpha = -2$ and $\small \beta = 1$.

Lets simulate the data:

```{r class.source = 'fold-show'}
set.seed(1)
N = 10000
X = rep(c(0,1),N/2) %>% sort()
thresholds = -3 + X
pass = rlogis(N) > thresholds
```

We estimate the model:

```{r class.source = 'fold-show'}
q.fit = quap(
  alist(
    pass ~ dbinom(1,p),
    logit(p) ~ -(a + b*X),
    a ~ dnorm(0,3),
    b ~ dnorm(0,3)
  ),
  data = list(pass = pass, X = X)
)
precis(q.fit) %>% 
  round(2)
```

Due to simulation noise we are not exactly recovering the parameters, but we are getting the correct thresholds with `r precis(q.fit)$mean[1] %>% round(2)` at baseline and a + b =  `r precis(q.fit)$mean[1] %>% round(2)` + `r precis(q.fit)$mean[2] %>% round(2)` = `r sum(precis(q.fit)$mean) %>% round(2)` for individuals where X = 1.

This shows us again that regression weights in logistic regressions represent changes in log odds ratios due to a predictor variable.

# Ordinal logistic regression

## A simple threshold / intercepts only model

Ordinal logistic regressions are named as such, because just like logistic regressions they assume a latent logistic variable that determines responses. Differently than standard logistic regression, ordered logistic regressions use multiple thresholds, which are used to map the latent variable onto ordered responses:

```{r out.width="60%"}
plot_dlogis.thresh = function(thresholds) {
  curve(dlogis(x),-6,6,xlim = c(-5,5),
        xlab = "latent scholastic aptitude")
  n_cat = length(thresholds) + 1
  clrs =
    colorRampPalette(c("blue","blue4"))(n_cat)
  for (k in 1:n_cat) {
    st = ifelse(k == 1, -6, thresholds[k-1])
    en = ifelse(k == n_cat, 6, thresholds[k])
    x = seq(st,en,.1)
    polygon(c(min(x),x,max(x)), c(0,dlogis(x),0), col = clrs[k])
    abline(v = thresholds[k], lty = 2, col = "red", lwd = 2)
    text((st+en)/2,dlogis(0)/2,paste0("R=",k), col = "grey50", cex = 1.5)
    text(thresholds[k],dlogis(0),thresholds[k], col = "red", pos = 2)
  }
}
thresholds = c(-2,0,2)
n_cat = length(thresholds) + 1
clrs = colorRampPalette(c("blue","blue4"))(n_cat)
set_par(cex = 1.5)
plot_dlogis.thresh(thresholds)
```

Just as we can use the (cumulative) logistic distribution to recover threshold values (log odds ratios) for the simple logistic regression, we can use it to recover threshold from an ordered logistic model.

For instance, the first threshold is:

```{r class.source = 'fold-show'}
log(plogis(-2)/(1-plogis(-2)))
```

As you might have guessed, we can also read the probability of different responses from the cumulative logit distribution:

```{r out.width="80%"}
plot_plogis.thresh = function(thresholds, plot.thrsh.eq = FALSE) {
  n_cat = length(thresholds) + 1
  clrs = 
    colorRampPalette(c("blue","blue4"))(n_cat) 
  curve(plogis(x),-6,6,xlim = c(-5,5),
        xlab = "latent scholastic aptitude")
  for (k in 1:n_cat) {
    s = ifelse(k == 1, -6, thresholds[k-1])
    e = ifelse(k == n_cat, 6, thresholds[k])
    curve(plogis(x), s,e, col = clrs[k], add = T, lwd = 2)
    
    b = ifelse(k == 1, 0, plogis(thresholds[k-1]))
    t = ifelse(k == n_cat, 1, plogis(thresholds[k]))
    x = seq(s,e,.1)
    y.p = c(plogis(x), plogis(max(x)))
    x.p = c(x,6)
    polygon(c(x.p,6),c(y.p,plogis(x[1])), col = clrs[k], border = "NA")
    arrows(x0 = -4, y1 = t, y0 = b, angle = 90, code = 3, length = .15)
    
    prob.level = 
      ifelse(
        k == 1,
        plogis(thresholds[k]),
        ifelse(
          k == n_cat,
          1-plogis(thresholds[k-1]),
          plogis(thresholds[k])-plogis(thresholds[k-1]))) %>% 
      round(2)
    text(-4, (b+t)/2, paste0("P(R=",k,")=", prob.level), pos = 4)
    
    if (k < n_cat) {
      p=plogis(thresholds[k])
      thrsh = log(p/(1-p)) %>% round(1)
      thrsh.equ = bquote(frac(.(round(p,2)),.(round(1-p,2)))~"=exp("~.(thrsh)~")")
      if (plot.thrsh.eq == TRUE) text(5.5,p,thrsh.equ, xpd = T, pos = 4)
      abline(h = p, lty = 2, col = "red")
    }
  }
  points(thresholds,rep(0,n_cat-1), pch = "|", col = "red")
}
set_par(cex = 1.5, mar = c(3,3,.5,7))
plot_plogis.thresh(thresholds, plot.thrsh.eq = TRUE)
```

Let's again simulate data from the model and estimate the thresholds.

Here we simulate data:

```{r class.source = 'fold-show'}
N = 1000
R = cut(
  rlogis(1000),
  breaks = c(-Inf,-2,0,2,Inf)) %>% 
  as.numeric()
```

which we can show as histogram and as cumulative counts:

```{r fig.height=4}
set_par(mfrow = c(1,2))
R %>% 
  table() %>% 
  barplot(ylab = "N",
          col = clrs,
          xlab = "Response")

m = diag(4)
m[upper.tri(m)] = 1
m = apply(m,2, function(x) x*R %>% table())
x = barplot(m, col = clrs,
        ylab = "cumulative N",
        xlab = "Response",
        names.arg = 1:n_cat)
ps = c(plogis(thresholds),1-plogis(max(thresholds)))
cs = c(0,plogis(thresholds),1)
for (k in 1:n_cat)
  text(tail(x,1),
       mean(cs[k:(k+1)])*N,
       round(ps[k],2),
       col ="white")
```


Here is an ordered logistic model:

```{r class.source = 'fold-show'}
ol.model = 
  alist(
    R ~ dordlogit(0,thresholds),
    thresholds ~ dnorm(0,3)
  )
```

The key different between the simple logistic and the ordered logistic regression is that the former has one threshold parameter:

$$
log \left( \frac{P(fail)}{P(success)} \right) = \alpha_k
$$

and the latter has $k = \small \textrm{1-number of levels}$ threshold parameters:

$$
log \left( \frac{P(R>\alpha_k)}{P(R<\alpha_k)} \right) = \alpha_k 
$$


The `dordlogit` **calculates the likelihood of the observation given the model using the `plogis` / `inv_logit` function, whereby different threshold values lead to different likelihoods**:

```{r, fig.width=10, fig.height=8}
set_par(mfrow = c(2,2))

thresh_list = list(thresholds,c(-3,-1,1))

for (k in 1:2) {
  thres = thresh_list[[k]]
  plot_plogis.thresh(thres)
  rbind(R %>% 
        table %>% 
        prop.table(),
      rlogis(100) %>% 
        cut(c(-Inf,thres,+Inf)) %>% 
        table %>% prop.table()) %>% 
  barplot(beside = T, 
          col = c("grey25","blue"),
          ylab="proportion",
          xlab = "Response")
legend("topleft", fill = c("grey25","blue"), 
       legend = c("data",expression("model | "~theta)), bty = "n")

}
```

So the basic ordered logistic regression model tries to find the correct threshold values that allow to reproduce the observed distribution of ratings.

We fit the model.
```{r class.source = 'fold-show', warning=FALSE, message=FALSE, results='hide'}
u.fit = ulam(
  ol.model,
  data=list(R=R),
  chains=4,cores=4)
```

And here are the estimated thresholds:

```{r class.source = 'fold-show', fig.height=3}
precis(u.fit, depth = 2) %>% plot()
threshold.est = precis(u.fit, depth = 2)[,1]
text(threshold.est,
     3:1,
     round(threshold.est,2), pos = 3)
```


As expected we recover the correct threshold values (with some error/bias due to simulation and prior).

## Ordinal logistic regression with predictors

To understand how to set up a model, such that a variable can increase or decrease the probability of higher response levels, lets look at the plot of latent variables an thresholds again. The plot also shows a hypothetical person with a latent scholastic aptitude of 0 as a white dot.

```{r, out.width="60%"}
set_par(cex = 1.5)
plot_dlogis.thresh(thresholds)
plotrix::draw.circle(0,.005,radius = .1,col = "white")
```

If we want to increase the chance that this hypothetical person achieves a rating of R = 3, we can either increase the value of the latent variable scholastic aptitude or shift the the thresholds to the left:

```{r, fig.height=5, fig.width=10, out.width="120%"}
set_par(mfrow = c(1,2),cex = 1.25)
thresholds = c(-2,0,2)
plot_dlogis.thresh(thresholds)
arrows(x0 = 0, x1 = 1, y0 = .005, length = .1, col = "white")
plotrix::draw.circle(1,.005, radius = .1,col = "white")
plotrix::draw.circle(0,.005, radius = .1,col = adjustcolor("white",alpha = .75))


thresholds = c(-3,-1,1)
plot_dlogis.thresh(thresholds)
abline(v = thresholds+1, col = adjustcolor("red",alpha = .25), lty = 2)
arrows(x0 = thresholds+1, x1 = thresholds,
       y0 = c(seq(.025,.075,length.out = 3)),
       col = "red", length = .1)
plotrix::draw.circle(0,.005,radius = .1,col = "white")
```

If we shift the latent value or the thresholds by the same amount, the probability of a higher response rises equally. In both plots above the bright white dot is in in the middle between the 2/3 and 3/4 thresholds.

Therefore we can, as we saw earlier for the logistic regression, add terms for individual level effects to the basic threshold / intercept only model to capture the effect of predictor variables on responses:

$$
log \left( \frac{P_i(R>\alpha_k)}{P_i(R<\alpha_k)} \right) = \alpha_k + \beta \cdot X_i
$$
where $\small \alpha_k$ are thresholds and $\beta$ captures the effect of the variable $X$ by modifying each individuals threshold.

Now we have seen previously that a threshold is just the log odds of responding in a category above vs below the threshold. Therefore, **a positive (negative) regression weight in an ordinal logistic regression should be interpreted as the log odds ratio to give a one level higher (lower) response**, i.e. R = 4 instead of R = 3 (R = 3 instead of R = 4).

Because there is only one regression weight $\small \beta$, the log odds ratios are the same for all category transitions, i.e. 

$$
log \left( \frac{P_i(R>\alpha_1|X = 0)}{P_i(R<\alpha_1|X = 1)} \right) = 
log \left( \frac{P_i(R>\alpha_2|X = 0)}{P_i(R<\alpha_2|X = 1)} \right) = 
log \left( \frac{P_i(R>\alpha_3|X = 0)}{P_i(R<\alpha_3|X = 1)} \right)
$$

This is referred to as the proportional odds assumptions, which may or may not be true.

To see the ordered logistic regression in action, we'll use the example data from the Portugues school again. In particular, we are looking at the (coarsened) first grade and estimate again the association with maternal education.

```{r out.width="80%", fig.height=4}
df=read.table("../Chapter11/data/student-mat.csv",sep=";",header=TRUE)
df = df[df$Medu>0,]
set_par()
df$G1 = as.numeric(cut(df$G1, breaks = seq(0,20,2),include.lowest = T))-1
df$G1 %>% table() %>% barplot()
```

To recapitulate the thresholds are just odds ratios at category boundaries, lets calculate them:

```{r class.source = 'fold-show'}
cum_prob = df$G1 %>% 
  table() %>% 
  prop.table() %>% 
  cumsum()
cum_prob = cum_prob[cum_prob!=1]
simple_thresholds = log(cum_prob/(1-cum_prob))
simple_thresholds %>% round(2)
```


And we estimate a thresholds only model with `ulam`:

```{r class.source = 'fold-show', warning=FALSE, message=FALSE, results='hide'}
tm.fit = ulam(
  alist(
    G1 ~ dordlogit(0,thresholds),
    thresholds ~ dnorm(0,3)
  ),
  data=list(G1 = df$G1),
  chains=4,cores=4)
```

And we plot the simple thresholds calculated manually against those estimated with ulam:

```{r, out.width="60%"}
post = extract.samples(tm.fit)
ulam_thresholds = colMeans(post$thresholds)
CI = apply(post$thresholds, 2, PI)
set_par(cex=1.5)
plot(simple_thresholds,
     ulam_thresholds,
     ylim = range(CI),
     pch = 16, col = "blue")
arrows(x0 = simple_thresholds,
       y0 = CI[1,], y1 = CI[2,],
       col = "blue", length = 0)
abline(0,1,lty = 3, col = "grey")
```
Now that we have understood thresholds, lets implement a model that uses predictor.
Specifically, we estimate the effect of past failure and maternal education on grades.

```{r class.source = 'fold-show'}
ol.model = 
  alist(
    G1 ~ dordlogit(phi,thresholds),
    phi <- bM*Medu + iFE*failures,
    iFE <- bF + bFE*Medu,
    c(bF, bM, bFE) ~ normal(0,1),
    thresholds ~ dnorm(0,3)
  )
```

We fit the model.
```{r class.source = 'fold-show', warning=FALSE, message=FALSE, results='hide'}
ol.fit = ulam(
  ol.model,
  data=list(G1 = df$G1, Medu = df$Medu, failures = df$failures),
  chains=4,cores=4)
```


We first just check Rhat values to make sure the model converged:

```{r class.source = 'fold-show'}
precis(ol.fit, depth = 2) %>% round(3)
```

This looks OK.

As a quick posterior predictive check we compare the histogram of the observed and predicted grades. We use the `sim` function instead of the `link` function to get posterior predictions on the scale of the ordered outcome variable.

```{r out.width="60%"}
set_par()

pp = sim(ol.fit)
obs.counts = cut(df$G1, breaks = seq(.5,10.5,1)) %>% table()
plot(obs.counts, 's', xaxt = "n", ylim = c(0,110)) 
axis(1,at = (1:9)+.5, labels = 1:9, lwd = 2)
for (k in 1:250) {
  pp.counts = cut(pp[k,], breaks = seq(.5,10.5,1)) %>% table()
  lines(1:10, pp.counts, 's', col = adjustcolor("blue",".25"))
}
```


Lets quickly compare the thresholds with thresholds from a thresholds only model again:
```{r, out.width="60%"}
post = extract.samples(ol.fit)
ulam_thresholds = colMeans(post$thresholds)
CI = apply(post$thresholds, 2, PI)
set_par(cex=1.5)
plot(simple_thresholds,
     ulam_thresholds,
     ylim = range(CI),
     pch = 16, col = "blue")
arrows(x0 = simple_thresholds,
       y0 = CI[1,], y1 = CI[2,],
       col = "blue", length = 0)
abline(0,1,lty = 3, col = "grey")
```

Because the model now also estimates effects of education and past failures, the thresholds are different. Only if the the covariates would be independent of grades would we expect to see identical thresholds.

Now lets look at the coefficients of interest:

```{r class.source = 'fold-show', fig.height=3}
coeffs = precis(ol.fit, pars = c("bM","bF","bFE"))
coeffs %>% plot()
coeffs %>% round(2)
```

What do these results mean?

- for each level of maternal education the odds ratio to get a one level higher grade is exp(`r round(coeffs["bM",1],2)`) = `r round(exp(coeffs["bM",1]),2)`
- for each paste fail the odds ratio to get a one level higher grade is exp(`r round(coeffs["bF",1],2)`) = `r round(exp(coeffs["bF",1]),2)`, though we are uncertain that the odds ratio is less than 1.
- the "effect" of past fails depends on maternal education, with a log odd ratio of `r round(coeffs["bFE",1],2)`

It is a bit hard to interpret these results because they are on the log odds ratio scale and because it is not totally clear (to me) how to interpret interaction effects. Therefor, we use posterior predictions to understand the results better.

First, we create posterior predictions for all levels of maternal education and past fails:

```{r class.source = 'fold-show'}
sim.data = expand.grid(
  Medu = sort(unique(df$Medu)),
  failures = sort(unique(df$failures)))

pp = sim(ol.fit,data = sim.data)
```

Here is a general overview:

```{r, out.width="60%"}
mu = colMeans(pp)
CI = apply(pp,2,PI)
set_par(cex = 1.5)
plot(0,type = "n", xlim = c(0.5,4.5),
     ylim = range(CI), xaxt = "n",
     xlab = "previous fails",
     ylab = "grade")
axis(1,at = 1:4)

for (Medu in 1:4) {
  idx = sim.data$Medu == Medu
  x = (1:4)+(Medu-2.5)/6
  points(x,mu[idx], pch = 16, col = Medu)
  arrows(x0 = x, y0 = CI[1,idx], y1 = CI[2,idx], length = 0, col = Medu)
}
legend("topright", pch = 16, col = 1:4, legend = 1:4, title = "Medu", bty = "n")
```

This plot suggests several questions:

- do grades decrease from 1 to 4 previous fails?
- is higher maternal education associated with higher grades when there were no previous fails and with lower grades when there were previous fails?
- are the above mentioned slopes robustly different?




# Summary