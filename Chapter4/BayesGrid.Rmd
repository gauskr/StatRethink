---
title: "BayesGrid"
author: "GB"
date: "24.03.2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Exercise: Program a simple grid approximation to obtain a posterior distribution

Please download a copy of [BayesGrid.Rmd](https://raw.githubusercontent.com/gbiele/StatRethink/master/Chapter4/BayesGrid.Rmd) and the data file [arrival.csv](https://raw.githubusercontent.com/gbiele/StatRethink/master/Chapter4/arrival.csv) into the same folder and fill in the relevant sections below.

To download the files follow the link and right-click anywhere on the page and the click "save as".

# The data Data

Use this data about arrivals times relative to the start of a lecture.

```{r}
my_data = 
  read.table(
    "arrival.csv",
    header = T,
    sep = ",")
head(my_data)
```

Here is the plot of the data

```{r}
with(my_data,
     plot(age, time))
```

```{r}
age = my_data$age
hist(age)
```


# The Model

For now, we are only interested in estimating the mean age (`age`) using the following model.
The table shows the incomplete model expressed with equations, `quap` code fragments, and how one would calculate quantities directly in R.

<br/>

| What | Notation | quap code | R code |
|---|---|---|---|
|Likelihood | $a_i \sim Normal(\mu,\sigma)$ | `age ~ dnorm(mu, sigma)` | `L[i] = dnorm(age[i], mu, sigma)` |
|Prior | $\mu \sim Normal(.,.)$ | `mu ~ dnorm(. , .)` | `p_mu = dnorm(. , .)` |
|Prior | $\sigma \sim \dots$ | `sigma ~ ...` | `p_sigma ~ ...` |

<br/>

Your first task is to complete the model to do this. Please add the missing information in the table above. You need to add the parameter values to the prior for $\mu$ and you have to choose a distribution and parameter(s) for the standard deviation $\sigma$.

### The posterior disribution

The posterior distribution is calculated as follows:

$$
\overset{Posterior}{P(\mu,\sigma|w)} = 
\frac{\prod_i \overset{Likelihood}{Normal(a_i|\mu,\sigma)} \cdot 
              \overset{Prior}{Normal(\mu|...,...)YourDist(\sigma|...)}}
{\overset{Evidence}{\int\int \prod_i Normal(a_i|\mu,\sigma) \cdot Normal(\mu|...,...)YourDist(\sigma|...)d\mu d\sigma}}
$$

<br/>

Please add the missing information, using what you just added to the table, wherever are three dots $...$ or it reads $YourDist$.

### Calculate the likelihood for a data point

Let's assume these parameter values

- `mu = 22`
- `sd = 3`

Please calculate the likelihood for the first data point in the vector `temp` in the next code block.
If you are uncertain about how to proceed, check the table above

```{r}
# Likelihood for the first data point

```


Now calculate the probability of the data point given the parameter values for each recorded age You do not need a loop to do this!

```{r}
# Likelihoods for all individual data points

```

And now calculate the joint probability of all recorded ages. (Read the help for the `prod` function, i.e. type `?prod`in the console)

```{r}
# Joint likelihood for all individual data points

```


Now calculate the prior probability of the the parameters `mu = 22` and `sd = 3`. You should use the prior distributions you specified above for this.

```{r}
# Prior probability for mu = 22

# Prior probability for sd = 3

```

And the joint prior probability for `mu = 22` and `sd = 2`.
```{r}
# Joint prior probability for mu = 22 and sd = 3

```

By putting the code you wrote until now, you should be able to calculate the numerator of the equation above, i.e. likelihood times prior probability (density), for parameters `mu = 22` and `sd = 3`. 

```{r}
# Joint probability of data and parameters for  mu = 22 and sd = 3 
# given the prior distributions for mu and sd

```

# Grid approximation

Now that you have calculated the joint likelihood of data and parameters given the prior distributions for `mu` and `sd` for one set of parameters, you can do this for a larger number of parameters combinations, which we can generate by constructing a grid where each point is a combination of one `mu` and one `sd` parameter value. Continue either with __Grid approximation, version 1__ or __Grid approximation, version 2__.

## Grid approximation, version 1

First set up the grid. You can use the the code example below. Feel free to change the range of the parameters you explore by changing the first and second number in the `seq` commands 

```{r}
# Here we are making our grid
# expand.grid produces all combinations 
# of the N (here 2) variables submitted
# and punts them in a matrix with N columns
params = 
  expand.grid(
    mu = seq(20,30,.1),
    sd = seq(2.5,4.5, .025)
  )
params = data.frame(params)
head(params)
tail(params)
```


Now you can calculate the unnormalized posterior for all parameter combinations.  It is easiest to use a for loops for this.

Store the result for each parameter combination in the the variable `UP`. Set "eval = TRUE" at the beginning of the code block, so tha the code is executed when you knit the document!

```{r, eval=FALSE}
# Here comes your code in which you calculate the 'likelihood * prior expression'
# (see the formula or your code above) for each combination of parameter values.
params$UP = NA
for (k in 1:nrow(params)) {
  params$UP[k] = 
}
```


### Calculate the evidence

Use the data.frame `params` that you just created, specifically one column in it, to calculate the _evidence_. If you are uncertain, check the equation above

```{r}
# Calculate the evidence from the unnormalized posterior

```


### Normalize to get a proper posterior distribution.

Now you can use the evidence to add a one more column to the `params` data frame, let's call it `PP`, which has the posterior probability for each parameter combination.
```{r}
# Calculate posterior probabilities

```


### Plot the posterior
Make a plot of the posterior
```{r}
# Plot posterior probabilities
# The easiest is to use ggplot here, following this pattern
# ggplot(params, aes(x = mu, y = sd, z = PP)) + geom_contour_filled()
# which assumes that you have called you column for posterior
# probabilities "PP"
library(ggplot2)

```


## Grid approximation, version 2

Here is a template to generate a grid of parameters. Your main task here is to add

- the upper and lower boundaries for the parameter values you want to explore in the grid
- the code to calculate the unormalized (or standardized) posterior.

You have to set `eval = TRUE` at the beginning of the code block so that the code is run when you knit the document.

```{r, eval = FALSE}
N_grid_points <-100

# Make a set of grid values for the two parameters
# replace the __ with values of your choice
my_mu<-seq(from=__, to=__, length.out=N_grid_points)
my_sigma<-seq(from=0, to=__, length.out=N_grid_points)

# Make an empty placeholder for the posterior
posterior_unstandardized<-matrix(NA,ncol=N_grid_points, nrow=N_grid_points)

# Calculate the posterior in each grid point
for (i in 1:N_grid_points)
  for (j in 1:N_grid_points)
  {
    posterior_unstandardized[i,j]<- # your code comes here
  }
```

Next, you need to calculate the evidence and standardize the posterior. Don't forget to change "eval = FALSE" to "eval = TRUE".

```{r, eval = FALSE}
posterior = 
```

And here is some code to plot the results

Plot the results. Don't forget to change "eval = FALSE" to "eval = TRUE".
```{r, eval = FALSE}
# Plot (2D) image of the posterior
image(my_mu,my_sigma,posterior,  axes=FALSE);
axis(1, at = seq(20, 30, by = 2))
axis(2, at = seq(0, 5, by = 1))

# Plot (3D) histogram
library(plot3D)
hist3D(z=posterior, border="black")
```

